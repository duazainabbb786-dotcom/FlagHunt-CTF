// ===== GAME STATE =====
const GameState = {
    score: 0,
    timeLeft: 90 * 60,
    flagsFound: 0,
    currentChallenge: 1,
    hintsRemaining: 3,
    soundEnabled: true,
    challenges: [],
    currentScenario: 1,
    terminalHistory: []
};

// ===== PROFESSIONAL CHALLENGES =====
const Challenges = [
    {
        id: 1,
        name: "STACK BUFFER OVERFLOW",
        description: "Memory corruption vulnerability",
        flag: "flag{buffer_overflow_triggered}",
        hint: "The buffer accepts 16 bytes of input. Consider what happens when you exceed this limit.",
        scenario: "A vulnerable login system with fixed buffer size. The isAdmin flag resides adjacent to the buffer.",
        answer: "AAAAAAAAAAAAAAAAAAAA",
        terminalCommand: "check_bof",
        status: "active",
        points: 150,
        timeBonus: 200
    },
    {
        id: 2,
        name: "RETURN ADDRESS CONTROL",
        description: "Code flow hijacking",
        flag: "flag{return_address_controlled}",
        hint: "Locate the win() function address and overwrite the saved return pointer.",
        scenario: "Unsafe string copy allows overwriting stack frames. Redirect execution to privileged function.",
        answer: "win",
        terminalCommand: "redirect_flow",
        status: "locked",
        points: 200,
        timeBonus: 250
    },
    {
        id: 3,
        name: "SHELLCODE INJECTION",
        description: "Arbitrary code execution",
        flag: "flag{shell_spawned_successfully}",
        hint: "The stack segment has execute permissions. Place your payload and jump to it.",
        scenario: "Executable stack region allows direct shellcode injection and execution.",
        answer: "shell",
        terminalCommand: "spawn_shell",
        status: "locked",
        points: 250,
        timeBonus: 300
    },
    {
        id: 4,
        name: "ROP CHAIN CONSTRUCTION",
        description: "Code reuse attack",
        flag: "flag{rop_chain_executed}",
        hint: "Find gadgets ending with 'ret' instructions to build your chain.",
        scenario: "DEP prevents shellcode execution. Use existing code fragments (gadgets) to bypass.",
        answer: "gadget",
        terminalCommand: "build_rop",
        status: "locked",
        points: 300,
        timeBonus: 350
    },
    {
        id: 5,
        name: "FORMAT STRING EXPLOIT",
        description: "Memory information leak",
        flag: "flag{format_string_leak}",
        hint: "Format specifiers can read from the stack. Try positional parameters.",
        scenario: "Unsanitized format string allows reading arbitrary memory locations.",
        answer: "%s",
        terminalCommand: "leak_memory",
        status: "locked",
        points: 250,
        timeBonus: 300
    },
    {
        id: 6,
        name: "HEAP METADATA CORRUPTION",
        description: "Heap exploitation",
        flag: "flag{heap_metadata_corrupted}",
        hint: "Overflow into adjacent chunk's metadata to control allocation.",
        scenario: "Heap-based overflow allows corruption of malloc metadata structures.",
        answer: "heap",
        terminalCommand: "corrupt_heap",
        status: "locked",
        points: 350,
        timeBonus: 400
    },
    {
        id: 7,
        name: "USE-AFTER-FREE",
        description: "Dangling pointer exploit",
        flag: "flag{use_after_free_exploited}",
        hint: "Free object, reallocate with controlled data, trigger dangling reference.",
        scenario: "Freed memory continues to be referenced, allowing type confusion.",
        answer: "uaf",
        terminalCommand: "exploit_uaf",
        status: "locked",
        points: 400,
        timeBonus: 450
    },
    {
        id: 8,
        name: "INTEGER OVERFLOW",
        description: "Numerical boundary bypass",
        flag: "flag{integer_overflow_triggered}",
        hint: "Maximum unsigned integer value wraps to zero on overflow.",
        scenario: "Integer size calculation overflow leads to buffer under-allocation.",
        answer: "999999",
        terminalCommand: "overflow_int",
        status: "locked",
        points: 250,
        timeBonus: 300
    },
    {
        id: 9,
        name: "ASLR BYPASS",
        description: "Address space randomization defeat",
        flag: "flag{aslr_bypassed_successfully}",
        hint: "Information leak reveals randomized addresses. Calculate offsets.",
        scenario: "Address Space Layout Randomization requires information disclosure for bypass.",
        answer: "aslr",
        terminalCommand: "bypass_aslr",
        status: "locked",
        points: 450,
        timeBonus: 500
    },
    {
        id: 10,
        name: "STACK CANARY BYPASS",
        description: "Stack protection circumvention",
        flag: "flag{stack_canary_bypassed}",
        hint: "Canary value must be preserved during overflow. Leak it first.",
        scenario: "Stack canary protects return addresses but can be leaked and restored.",
        answer: "canary",
        terminalCommand: "bypass_canary",
        status: "locked",
        points: 400,
        timeBonus: 450
    },
    {
        id: 11,
        name: "RETURN-TO-LIBC",
        description: "Library function redirection",
        flag: "flag{ret2libc_success}",
        hint: "Use libc functions directly. Locate system() and string constants.",
        scenario: "Bypass NX by returning into existing library functions with controlled arguments.",
        answer: "libc",
        terminalCommand: "ret2libc",
        status: "locked",
        points: 350,
        timeBonus: 400
    },
    {
        id: 12,
        name: "FULL CHAIN EXPLOIT",
        description: "Multi-stage vulnerability chain",
        flag: "flag{full_pwn_complete_congratulations}",
        hint: "Chain information leak with control flow hijack for complete system compromise.",
        scenario: "Combined exploitation requiring multiple vulnerability chaining for privilege escalation.",
        answer: "victory",
        terminalCommand: "full_exploit",
        status: "locked",
        points: 500,
        timeBonus: 500
    }
];

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
    initGame();
    initTerminal();
    renderChallenges();
    renderScenarios();
    startTimer();
    initSounds();
    initEventListeners();
});

function initGame() {
    GameState.challenges = [...Challenges];
    GameState.challenges[0].status = "active";
    updateUI();
}

function initEventListeners() {
    // Initialize hover sounds
    document.querySelectorAll('.challenge-card, .cmd-btn, .nav-btn, .control-btn').forEach(el => {
        el.addEventListener('mouseenter', () => playSound('hover', 0.2));
        el.addEventListener('click', () => playSound('click', 0.3));
    });
}

// ===== TERMINAL FUNCTIONS =====
function initTerminal() {
    const input = document.getElementById('command-input');
    
    // Professional welcome message
    addTerminalOutput(`
<span class="cyber-text">================================================</span>
<span class="text-success">Â» PWNED: BINARY EXPLOITATION ARENA</span>
<span class="text-success">Â» Security Audit Interface v2.5</span>
<span class="text-success">Â» Memory Analysis Tools: ONLINE</span>
<span class="text-success">Â» Exploit Database: SYNCED</span>
<span class="cyber-text">================================================</span>
<span class="text-info">Type 'help' for command list</span>
<span class="text-info">Active Target: ${Challenges[0].name}</span>
<span class="text-warning">Time Allocation: 89:59</span>
<span class="cyber-text">================================================</span>
    `);
    
    input.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            executeCommand();
        }
    });
    
    input.focus();
}

function executeCommand() {
    const input = document.getElementById('command-input');
    const command = input.value.trim();
    
    if (!command) return;
    
    addTerminalOutput(`<span class="prompt"><span class="prompt-user">root</span>@<span class="prompt-host">pwned-arena</span>:<span class="prompt-path">~/exploits</span># ${command}</span>`);
    
    processCommand(command.toLowerCase());
    input.value = '';
    playSound('type');
}

function processCommand(cmd) {
    const args = cmd.split(' ');
    const mainCmd = args[0];
    
    switch(mainCmd) {
        case 'help':
        case '?':
            showHelp();
            break;
        case 'check_bof':
            startChallenge(1);
            break;
        case 'redirect_flow':
            startChallenge(2);
            break;
        case 'spawn_shell':
            startChallenge(3);
            break;
        case 'build_rop':
            startChallenge(4);
            break;
        case 'leak_memory':
            startChallenge(5);
            break;
        case 'corrupt_heap':
            startChallenge(6);
            break;
        case 'exploit_uaf':
            startChallenge(7);
            break;
        case 'overflow_int':
            startChallenge(8);
            break;
        case 'bypass_aslr':
            startChallenge(9);
            break;
        case 'bypass_canary':
            startChallenge(10);
            break;
        case 'ret2libc':
            startChallenge(11);
            break;
        case 'full_exploit':
            startChallenge(12);
            break;
        case 'submit':
            if (args.length > 1) {
                const answer = args.slice(1).join(' ');
                checkAnswer(answer);
            } else {
                addTerminalOutput('<span class="text-danger">Usage: submit [exploit_payload]</span>');
            }
            break;
        case 'status':
            showStatus();
            break;
        case 'clear':
            clearTerminal();
            break;
        case 'hint':
            showHint();
            break;
        default:
            addTerminalOutput(`<span class="text-danger">Command not found: ${cmd}</span>`);
            addTerminalOutput('<span class="text-info">Type "help" for available commands</span>');
    }
}

function showHelp() {
    const helpText = `
<span class="cyber-text">========== COMMAND REFERENCE ==========</span>
<span class="command">help</span>                   - Display this reference
<span class="command">check_bof</span>             - Target 1: Stack Buffer Overflow
<span class="command">redirect_flow</span>         - Target 2: Return Address Control
<span class="command">spawn_shell</span>           - Target 3: Shellcode Injection
<span class="command">build_rop</span>             - Target 4: ROP Chain Construction
<span class="command">leak_memory</span>           - Target 5: Format String Exploit
<span class="command">corrupt_heap</span>          - Target 6: Heap Metadata Corruption
<span class="command">exploit_uaf</span>           - Target 7: Use-After-Free
<span class="command">overflow_int</span>          - Target 8: Integer Overflow
<span class="command">bypass_aslr</span>           - Target 9: ASLR Bypass
<span class="command">bypass_canary</span>         - Target 10: Stack Canary Bypass
<span class="command">ret2libc</span>              - Target 11: Return-to-Libc
<span class="command">full_exploit</span>          - Target 12: Full Chain Exploit
<span class="command">submit [payload]</span>      - Deploy exploit payload
<span class="command">status</span>                 - Display mission status
<span class="command">hint</span>                   - Request strategic intel
<span class="command">clear</span>                  - Clear terminal buffer
<span class="cyber-text">======================================</span>
    `;
    addTerminalOutput(helpText);
}

function showStatus() {
    const current = Challenges[GameState.currentChallenge - 1];
    const statusText = `
<span class="cyber-text">============ MISSION STATUS ============</span>
<span class="text-info">Credits: ${GameState.score}</span>
<span class="text-info">Targets Neutralized: ${GameState.flagsFound}/12</span>
<span class="text-info">Time Remaining: ${formatTime(GameState.timeLeft)}</span>
<span class="text-info">Active Target: ${current.name}</span>
<span class="text-info">Strategic Intel: ${GameState.hintsRemaining} remaining</span>
<span class="cyber-text">=======================================</span>
    `;
    addTerminalOutput(statusText);
}

// ===== CHALLENGE FUNCTIONS =====
function startChallenge(id) {
    const challenge = Challenges[id - 1];
    
    if (!challenge) {
        addTerminalOutput('<span class="text-danger">Invalid target designation</span>');
        return;
    }
    
    if (challenge.status === 'locked') {
        addTerminalOutput(`<span class="text-danger">Target locked! Neutralize target ${id - 1} first.</span>`);
        return;
    }
    
    GameState.currentChallenge = id;
    updateUI();
    
    addTerminalOutput(`
<span class="cyber-text">======== TARGET ${id}: ${challenge.name} ========</span>
<span class="text-info">${challenge.scenario}</span>
<span class="text-warning">Deploy exploit with: submit [payload]</span>
<span class="text-info">Type 'hint' for strategic intel (-50 credits)</span>
<span class="cyber-text">=============================================</span>
    `);
}

function checkAnswer(answer) {
    const challenge = Challenges[GameState.currentChallenge - 1];
    
    if (!challenge) {
        addTerminalOutput('<span class="text-danger">No active target!</span>');
        return;
    }
    
    // Flexible answer checking
    const isCorrect = answer.toLowerCase().includes(challenge.answer.toLowerCase());
    
    if (isCorrect) {
        playSound('success', 0.5);
        completeChallenge(challenge);
    } else {
        playSound('error', 0.3);
        addTerminalOutput('<span class="text-danger">âœ— Exploit failed! Payload rejected.</span>');
        addTerminalOutput('<span class="text-info">Analyze vulnerability and retry.</span>');
    }
}

function completeChallenge(challenge) {
    challenge.status = 'completed';
    GameState.flagsFound++;
    
    const timeBonus = Math.max(50, challenge.timeBonus - Math.floor((90 * 60 - GameState.timeLeft) / 60));
    const totalPoints = challenge.points + timeBonus;
    GameState.score += totalPoints;
    
    if (challenge.id < 12) {
        Challenges[challenge.id].status = 'active';
    }
    
    updateUI();
    renderChallenges();
    renderScenarios();
    
    showSuccessModal(challenge, totalPoints, timeBonus);
    
    addTerminalOutput(`
<span class="text-success">âœ” TARGET NEUTRALIZED</span>
<span class="text-success">Flag Acquired: ${challenge.flag}</span>
<span class="text-success">Credits Awarded: +${totalPoints}</span>
<span class="text-success">Next Target: ${Challenges[challenge.id]?.name || 'MISSION COMPLETE'}</span>
    `);
    
    if (GameState.flagsFound === 12) {
        setTimeout(completeGame, 2000);
    }
}

// ===== UI UPDATES =====
function updateUI() {
    document.getElementById('score').textContent = GameState.score;
    document.getElementById('flags-count').textContent = `${GameState.flagsFound}/12`;
    document.getElementById('difficulty').textContent = 'ADVANCED';
    
    const progress = (GameState.flagsFound / 12) * 100;
    document.getElementById('progress-percent').textContent = `${Math.round(progress)}%`;
    document.getElementById('progress-fill').style.width = `${progress}%`;
    
    const current = Challenges[GameState.currentChallenge - 1];
    if (current) {
        document.getElementById('current-objective').textContent = `${current.id}. ${current.name}`;
    }
}

function renderChallenges() {
    const container = document.getElementById('challenges-grid');
    container.innerHTML = '';
    
    Challenges.forEach(challenge => {
        const card = document.createElement('div');
        card.className = `challenge-card ${challenge.status}`;
        card.onclick = () => challenge.status !== 'locked' && startChallenge(challenge.id);
        
        let icon = 'fa-flag';
        let statusClass = 'status-locked';
        let statusText = 'LOCKED';
        
        if (challenge.status === 'active') {
            icon = 'fa-crosshairs';
            statusClass = 'status-active';
            statusText = 'ENGAGE';
        } else if (challenge.status === 'completed') {
            icon = 'fa-check-circle';
            statusClass = 'status-completed';
            statusText = 'NEUTRALIZED';
        }
        
        card.innerHTML = `
            <div class="challenge-icon">
                <i class="fas ${icon}"></i>
            </div>
            <div class="challenge-title">${challenge.id}. ${challenge.name}</div>
            <div class="challenge-desc">${challenge.description}</div>
            <div class="challenge-status ${statusClass}">${statusText}</div>
            <div class="challenge-points">${challenge.points} CR</div>
        `;
        
        container.appendChild(card);
    });
}

function renderScenarios() {
    const container = document.getElementById('scenarios-container');
    container.innerHTML = '';
    
    const startIdx = Math.max(0, GameState.currentScenario - 1);
    const scenarios = Challenges.slice(startIdx, startIdx + 2);
    
    scenarios.forEach((scenario, idx) => {
        const card = document.createElement('div');
        card.className = `scenario-card ${scenario.status === 'active' ? 'active' : ''}`;
        
        card.innerHTML = `
            <div class="scenario-number">TARGET ${scenario.id}</div>
            <div class="scenario-title">${scenario.name}</div>
            <div class="scenario-description">${scenario.scenario}</div>
            <div class="scenario-hint">
                <strong>Strategic Intel:</strong> ${scenario.hint}
            </div>
        `;
        
        container.appendChild(card);
    });
    
    document.getElementById('scenario-counter').textContent = 
        `${GameState.currentScenario}/${Challenges.length}`;
}

// ===== MODAL FUNCTIONS =====
function showSuccessModal(challenge, totalPoints, timeBonus) {
    const modal = document.getElementById('success-modal');
    const flagName = document.getElementById('captured-flag-name');
    const flagCode = document.getElementById('captured-flag');
    const successMessage = document.getElementById('success-message');
    const timeBonusEl = document.getElementById('time-bonus');
    const totalScoreEl = document.getElementById('total-score');
    
    flagName.textContent = challenge.name;
    flagCode.textContent = challenge.flag;
    successMessage.textContent = challenge.scenario;
    timeBonusEl.textContent = `+${timeBonus}`;
    totalScoreEl.textContent = totalPoints;
    
    createConfetti();
    modal.classList.add('active');
    playSound('success', 0.3);
}

function createConfetti() {
    const container = document.querySelector('.confetti-container');
    if (!container) return;
    
    container.innerHTML = '';
    const colors = ['#00ff9d', '#00f3ff', '#b967ff', '#ff2a6d', '#ffde59'];
    
    for (let i = 0; i < 80; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.width = `${Math.random() * 6 + 3}px`;
        confetti.style.height = `${Math.random() * 12 + 6}px`;
        confetti.style.animationDelay = `${Math.random() * 2}s`;
        container.appendChild(confetti);
    }
}

function continueChallenge() {
    document.getElementById('success-modal').classList.remove('active');
    const nextId = GameState.currentChallenge + 1;
    if (nextId <= 12) {
        startChallenge(nextId);
    }
}

function showHintModal() {
    const challenge = Challenges[GameState.currentChallenge - 1];
    const modal = document.getElementById('hint-modal');
    const content = document.getElementById('hint-content');
    
    content.innerHTML = `
        <h4>${challenge.name}</h4>
        <p>${challenge.hint}</p>
        <div class="mt-3">
            <strong>Exploitation Strategy:</strong>
            <ul class="mt-2">
                <li>Analyze binary with objdump/gdb</li>
                <li>Identify buffer boundaries</li>
                <li>Calculate precise offsets</li>
                <li>Test payloads incrementally</li>
            </ul>
        </div>
    `;
    
    modal.classList.add('active');
}

function closeHintModal() {
    document.getElementById('hint-modal').classList.remove('active');
}

function useHint() {
    if (GameState.hintsRemaining > 0) {
        GameState.hintsRemaining--;
        GameState.score = Math.max(0, GameState.score - 50);
        updateUI();
        closeHintModal();
        addTerminalOutput('<span class="text-warning">Strategic intel acquired! -50 credits</span>');
    }
}

function showHint() {
    const challenge = Challenges[GameState.currentChallenge - 1];
    addTerminalOutput(`<span class="text-info">Strategic Intel: ${challenge.hint}</span>`);
}

// ===== TIMER FUNCTIONS =====
function startTimer() {
    setInterval(() => {
        GameState.timeLeft--;
        
        if (GameState.timeLeft <= 0) {
            gameOver();
            return;
        }
        
        document.getElementById('timer').textContent = formatTime(GameState.timeLeft);
        updateObjectiveTimer();
        
        if (GameState.timeLeft === 10 * 60) {
            addTerminalOutput('<span class="text-danger">âš  CRITICAL: 10 minutes remaining!</span>');
            document.getElementById('timer').classList.add('pulse');
        }
    }, 1000);
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

function updateObjectiveTimer() {
    const elapsed = (90 * 60 - GameState.timeLeft) % 300;
    const remaining = 300 - elapsed;
    document.getElementById('objective-timer').textContent = formatTime(remaining);
}

// ===== GAME CONTROL FUNCTIONS =====
function toggleSound() {
    GameState.soundEnabled = !GameState.soundEnabled;
    const icon = document.getElementById('sound-icon');
    icon.className = GameState.soundEnabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';
    addTerminalOutput(`<span class="text-info">Audio ${GameState.soundEnabled ? 'enabled' : 'disabled'}</span>`);
}

function resetGame() {
    if (confirm('Reset mission? All progress will be lost.')) {
        location.reload();
    }
}

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(console.log);
    } else {
        document.exitFullscreen();
    }
}

function downloadPackage() {
    addTerminalOutput('<span class="text-info">Downloading challenge resources...</span>');
    // Simulate download
    setTimeout(() => {
        addTerminalOutput('<span class="text-success">âœ“ Resources downloaded successfully</span>');
    }, 1000);
}

function gameOver() {
    addTerminalOutput(`
<span class="cyber-text">================================</span>
<span class="text-danger">          TIME ALLOCATION EXHAUSTED</span>
<span class="text-danger">         MISSION TERMINATED</span>
<span class="cyber-text">================================</span>
<span class="text-info">Final Credits: ${GameState.score}</span>
<span class="text-info">Targets Neutralized: ${GameState.flagsFound}/12</span>
<span class="cyber-text">================================</span>
    `);
    
    setTimeout(() => {
        alert(`Mission Failed!\nCredits: ${GameState.score}\nTargets: ${GameState.flagsFound}/12`);
    }, 1000);
}

function completeGame() {
    addTerminalOutput(`
<span class="cyber-text">========================================</span>
<span class="text-success">       ALL TARGETS NEUTRALIZED</span>
<span class="text-success">      MISSION ACCOMPLISHED</span>
<span class="cyber-text">========================================</span>
<span class="text-success">Final Credits: ${GameState.score}</span>
<span class="text-success">Time Remaining: ${formatTime(GameState.timeLeft)}</span>
<span class="text-success">Security Clearance: ELITE</span>
<span class="cyber-text">========================================</span>
    `);
    
    setTimeout(() => {
        alert(`Mission Complete!\nFinal Credits: ${GameState.score}\nSecurity Clearance: ELITE`);
    }, 2000);
}

// ===== UTILITY FUNCTIONS =====
function addTerminalOutput(text) {
    const output = document.getElementById('terminal-output');
    const div = document.createElement('div');
    div.innerHTML = text;
    output.appendChild(div);
    output.scrollTop = output.scrollHeight;
}

function clearTerminal() {
    document.getElementById('terminal-output').innerHTML = '';
}

function quickCommand(cmd) {
    document.getElementById('command-input').value = cmd;
    executeCommand();
}

function prevScenario() {
    if (GameState.currentScenario > 1) {
        GameState.currentScenario--;
        renderScenarios();
    }
}

function nextScenario() {
    if (GameState.currentScenario < Challenges.length) {
        GameState.currentScenario++;
        renderScenarios();
    }
}

// ===== SOUND FUNCTIONS =====
function initSounds() {
    console.log("Audio systems initialized");
}

function playSound(type, volume = 0.5) {
    if (!GameState.soundEnabled) return;
    console.log(`Playing: ${type}`);
    // Sound implementation would go here
}
// ===== SOUND FUNCTIONS =====
function initSounds() {
    // Sound system already initialized
    console.log("ðŸ”Š Sound system ready");
}

function playSound(type, volume = 0.5) {
    if (typeof soundManager !== 'undefined') {
        soundManager.play(type, volume);
    }
}

// Add click sounds to all buttons
document.addEventListener('DOMContentLoaded', function() {
    // Button click sounds
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => {
        button.addEventListener('click', function() {
            playSound('click', 0.3);
        });
    });
    
    // Hover sounds
    const hoverElements = document.querySelectorAll('.challenge-card, .cmd-btn, .nav-btn, .control-btn');
    hoverElements.forEach(el => {
        el.addEventListener('mouseenter', function() {
            playSound('hover', 0.2);
        });
    });
    
    // Challenge card click
    const challengeCards = document.querySelectorAll('.challenge-card');
    challengeCards.forEach(card => {
        card.addEventListener('click', function() {
            playSound('click', 0.4);
        });
    });
    
    // Terminal input sound
    const terminalInput = document.getElementById('command-input');
    if (terminalInput) {
        terminalInput.addEventListener('keydown', function(e) {
            if (e.key.length === 1) { // Character keys only
                playSound('type', 0.1);
            }
        });
    }
});

// Toggle sound function
function toggleSound() {
    const enabled = soundManager.toggle();
    const icon = document.getElementById('sound-icon');
    if (icon) {
        icon.className = enabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';
    }
    
    // Show message in terminal
    addTerminalOutput(`<span class="text-info">Sound ${enabled ? 'enabled' : 'disabled'}</span>`);
}
// ===== SOUND INTEGRATION =====
function initSounds() {
    console.log("ðŸ”Š Sound system initialized");
}

function playSound(type, volume = 0.5) {
    if (typeof soundManager !== 'undefined') {
        soundManager.play(type, volume);
    }
}

// Toggle sound function
function toggleSound() {
    const enabled = soundManager.toggle();
    const icon = document.getElementById('sound-icon');
    if (icon) {
        icon.className = enabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';
    }
    
    addTerminalOutput(`<span class="text-info">Audio ${enabled ? 'activated' : 'muted'}</span>`);
    
    // Play test sound when enabling
    if (enabled) {
        setTimeout(() => playSound('click', 0.3), 100);
    }
}

// Add sound effects to all interactive elements
document.addEventListener('DOMContentLoaded', function() {
    // Button click sounds
    document.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', function() {
            playSound('click', 0.3);
        });
    });
    
    // Challenge card sounds
    document.querySelectorAll('.challenge-card').forEach(card => {
        card.addEventListener('mouseenter', function() {
            playSound('hover', 0.2);
        });
        card.addEventListener('click', function() {
            playSound('click', 0.4);
        });
    });
    
    // Quick command buttons
    document.querySelectorAll('.cmd-btn').forEach(btn => {
        btn.addEventListener('mouseenter', function() {
            playSound('hover', 0.15);
        });
    });
    
    // Navigation buttons
    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            playSound('click', 0.3);
        });
    });
    
    // Control panel buttons
    document.querySelectorAll('.control-btn').forEach(btn => {
        btn.addEventListener('mouseenter', function() {
            playSound('hover', 0.2);
        });
    });
    
    // Terminal input typing sound
    const terminalInput = document.getElementById('command-input');
    if (terminalInput) {
        terminalInput.addEventListener('keydown', function(e) {
            if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                playSound('type', 0.1);
            }
        });
    }
    
    // Test sound button (hidden)
    const testSoundBtn = document.createElement('button');
    testSoundBtn.innerHTML = 'ðŸ”Š Test Sound';
    testSoundBtn.style.position = 'fixed';
    testSoundBtn.style.bottom = '10px';
    testSoundBtn.style.right = '10px';
    testSoundBtn.style.zIndex = '9999';
    testSoundBtn.style.padding = '5px 10px';
    testSoundBtn.style.background = '#00f3ff';
    testSoundBtn.style.color = '#000';
    testSoundBtn.style.border = 'none';
    testSoundBtn.style.borderRadius = '5px';
    testSoundBtn.style.cursor = 'pointer';
    testSoundBtn.addEventListener('click', testAllSounds);
    document.body.appendChild(testSoundBtn);
});

// Test all sounds function
function testAllSounds() {
    console.log("Testing all sounds...");
    
    playSound('click', 0.4);
    setTimeout(() => playSound('type', 0.2), 200);
    setTimeout(() => playSound('hover', 0.3), 400);
    setTimeout(() => playSound('success', 0.5), 600);
    setTimeout(() => playSound('error', 0.4), 1000);
    
    addTerminalOutput('<span class="text-info">ðŸ”Š Playing sound test sequence...</span>');
}

// Add test command to terminal
// Add this to processCommand function in the switch statement:
// case 'test_sound':
//     testAllSounds();
//     break;